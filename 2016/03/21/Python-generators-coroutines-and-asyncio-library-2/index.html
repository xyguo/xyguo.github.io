<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Python coroutines and asyncio library (2) | Coupon Collector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Reading notes for the book *Fluent Python* and the `500lines/crawler` project">
<meta property="og:type" content="article">
<meta property="og:title" content="Python coroutines and asyncio library (2)">
<meta property="og:url" content="http://yoursite.com/2016/03/21/Python-generators-coroutines-and-asyncio-library-2/index.html">
<meta property="og:site_name" content="Coupon Collector">
<meta property="og:description" content="Reading notes for the book *Fluent Python* and the `500lines/crawler` project">
<meta property="og:updated_time" content="2016-06-20T07:37:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python coroutines and asyncio library (2)">
<meta name="twitter:description" content="Reading notes for the book *Fluent Python* and the `500lines/crawler` project">
  
    <link rel="alternate" href="/atom.xml" title="Coupon Collector" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Coupon Collector</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">miscellaneous notes</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/links">Links</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Python-generators-coroutines-and-asyncio-library-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/Python-generators-coroutines-and-asyncio-library-2/" class="article-date">
  <time datetime="2016-03-21T03:29:22.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python coroutines and asyncio library (2)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><p>Suitable for <strong>I/O-bound</strong> tasks.</p>
<h3 id="futures"><a href="#futures" class="headerlink" title="futures"></a><code>futures</code></h3><p>“futures” — objects representing the asynchronous execution of an operation<br>an instance of either <code>asyncio.Future</code> or <code>concurrent.futures.Future</code> class represents a <strong>deferred</strong> computation that may or may not have completed. This is similar to the <code>Deferred</code> class in Twisted, the <code>Future</code> class in Tornado, and <code>Promise</code> objects in various JavaScript libraries.</p>
<ul>
<li><code>concurrent.futures</code> is based on thread/process rather than coroutines.</li>
<li>Client code is not supposed to change the state of a future: the concurrency framework changes the state of a future when the computation it represents is done, and we can’t control when that happens.</li>
<li>Users should not create them: they are meant to be instantiated exclusively by the concurrency framework, be it <code>concurrent.futures</code> or <code>asyncio</code>.</li>
<li><code>concurrent.futures.ThreadPoolExecutor</code> ::</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> save_flag, get_flag, show, main </span><br><span class="line"></span><br><span class="line">MAX_WORKERS = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>) </span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    workers = min(MAX_WORKERS, len(cc_list))</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># the `.map` method works like the built-in `map` method; it returns a generator that can be iterated over to </span></span><br><span class="line">        <span class="comment"># retrieve the value returned by each function (`download_one` here).</span></span><br><span class="line">        <span class="comment"># When iterating on the generator returned by `.map`, the `__next__` call invokes the `.result` method of each</span></span><br><span class="line">        <span class="comment"># future, and yield the result if the future is done. So here we cannot touch futures directly.</span></span><br><span class="line">        res = executor.map(download_one, sorted(cc_list)) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># if any of the threaded calls raised an exception, that exception would be raised here as the implicit `next()`</span></span><br><span class="line">    <span class="comment"># call tried to retrieve the corresponding return value from the iterator.</span></span><br><span class="line">    <span class="keyword">return</span> len(list(res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    main(download_many)</span><br></pre></td></tr></table></figure>
<p><code>concurrent.futures.as_completed</code><br>An idiom that’s very useful with <code>futures.as_completed</code>: building a dict to map each future to other data that may be useful when the future is <strong>completed</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> flags2_common <span class="keyword">import</span> main, HTTPStatus </span><br><span class="line"><span class="keyword">from</span> flags2_sequential <span class="keyword">import</span> download_one</span><br><span class="line"></span><br><span class="line">DEFAULT_CONCUR_REQ = <span class="number">30</span></span><br><span class="line">MAX_CONCUR_REQ = <span class="number">1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=concur_req) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one,</span><br><span class="line">                            cc, base_url, verbose)</span><br><span class="line">            <span class="comment"># This dict will map each `Future` instance — representing one download — with the respective </span></span><br><span class="line">            <span class="comment"># country code for error reporting.</span></span><br><span class="line">            to_do_map[future] = cc</span><br><span class="line">        <span class="comment"># futures.as_completed returns an iterator that yields futures as they are done.</span></span><br><span class="line">        done_iter = futures.as_completed(to_do_map) </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> verbose:</span><br><span class="line">            done_iter = tqdm.tqdm(done_iter, total=len(cc_list)) </span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> done_iter:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                res = future.result()</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.HTTPError <span class="keyword">as</span> exc:</span><br><span class="line">                error_msg = <span class="string">'HTTP &#123;res.status_code&#125; - &#123;res.reason&#125;'</span> </span><br><span class="line">                error_msg = error_msg.format(res=exc.response)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> exc: </span><br><span class="line">                error_msg = <span class="string">'Connection error'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error_msg = <span class="string">''</span></span><br><span class="line">                status = res.status</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> error_msg:</span><br><span class="line">                status = HTTPStatus.error</span><br><span class="line">            counter[status] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">                <span class="comment"># This was not necessary in the sequential version because we were iterating over the list </span></span><br><span class="line">                <span class="comment"># of country codes, so we had the current `cc`; here we are iterating over the futures.</span></span><br><span class="line">                cc = to_do_map[future]</span><br><span class="line">                print(<span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span>.format(cc, error_msg))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)</span><br></pre></td></tr></table></figure>
<h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a><code>asyncio</code></h3><p>Integrated into the standard library in Python <strong>3.4</strong>. Provides a way to drive asynchronous programs using <strong>event loop</strong>, which is different from Node.js.</p>
<p>Compared to multi-thread solutions, coroutines resides in a single thread, thus avoids most overhead due to thread context-switch. Plus, any time there can be only one coroutine running and it give out control actively, thus avoids most headaches due to synchronization since the coroutine knows that it won’t be interrupted unless voluntary suspends with <code>yield</code> (or <code>yield from</code>).</p>
<p>Note that, by design, there is no API for terminating a <strong>thread</strong> in Python. You must send it a message to shut down. Due to the GIL, race condition is alleviated at the expense of losing parallism. While for a coroutines, it can only be cancelled when it’s suspended at a <code>yield</code> point, so you can perform cleanup by handling the <code>CancelledError</code> exception (see below).</p>
<h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><p>“coroutine” in the context of <code>asyncio</code><br>A coroutine suitable for use with the <code>asyncio</code> API must use <code>yield from</code> and <strong>not</strong> <code>yield</code> in its body. Also, an <code>asyncio</code> coroutine should be driven by a caller invoking it through <code>yield from</code> or by passing the coroutine to one of the <code>asyncio</code> functions such as <code>asyncio.async(...)</code>. Finally, the <code>@asyncio.coroutine</code> decorator should be applied to coroutines.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Coroutines intended for use with asyncio should be decorated with `@asyncio.coroutine`. </span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spin</span><span class="params">(msg)</span>:</span></span><br><span class="line">write, flush = sys.stdout.write, sys.stdout.flush </span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> itertools.cycle(<span class="string">'|/-\\'</span>):</span><br><span class="line">    status = char + <span class="string">' '</span> + msg write(status)</span><br><span class="line">    flush()</span><br><span class="line">    write(<span class="string">'\x08'</span> * len(status)) </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Use `yield from asyncio.sleep(.1)` instead of just `time.sleep(.1)`</span></span><br><span class="line">        <span class="comment"># to sleep without blocking the event loop.</span></span><br><span class="line">        <span class="comment"># Never use `time.sleep(...)` in `asyncio` coroutines unless you want to block the main thread,</span></span><br><span class="line">        <span class="comment"># therefore freezing the event loop and probably the whole application as well.</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">.1</span>) </span><br><span class="line">    <span class="comment"># The `CancelledError` exception can be catched in the `yield` where the coroutine is suspended.</span></span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">write(<span class="string">' '</span> * len(status) + <span class="string">'\x08'</span> * len(status))</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># pretend waiting a long time for I/O </span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">supervisor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># `asyncio.async(...)` schedules the `spin` coroutine to run, wrapping it in a `Task` </span></span><br><span class="line">    <span class="comment"># object, which is returned immediately. When you get a `Task` object, it is already scheduled to run</span></span><br><span class="line">    spinner = asyncio.<span class="keyword">async</span>(spin(<span class="string">'thinking!'</span>)) </span><br><span class="line">    print(<span class="string">'spinner object:'</span>, spinner)</span><br><span class="line">    result = <span class="keyword">yield</span> <span class="keyword">from</span> slow_function() </span><br><span class="line">    <span class="comment"># This raises `CancelledError` inside the coroutine.</span></span><br><span class="line">    spinner.cancel()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># Drive the supervisor coroutine to completion; </span></span><br><span class="line">    <span class="comment"># the return value of the coroutine is the return value of this call.</span></span><br><span class="line">    result = loop.run_until_complete(supervisor()) </span><br><span class="line">    loop.close()</span><br><span class="line">    print(<span class="string">'Answer:'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><code>asyncio.Futures</code> is designed to work with <code>yield from</code>  </p>
<ul>
<li>Using <code>yield from</code> with a future is the <strong>coroutine equivalent</strong> of the functionality offered by <code>add_donecallback</code>: instead of triggering a callback, when the delayed operation is done, the event loop sets the result of the future, and the <code>yield from</code> expression produces a return value inside our suspended coroutine, allowing it to resume.</li>
<li>You don’t need <code>my_future.add_donecallback(...)</code> because you can simply put whatever processing you would do after the future is done in the lines that follow <code>yield from my_future</code> in your coroutine. That’s the big advantage of having coroutines: functions that can be suspended and resumed.</li>
<li>You don’t need <code>my_future.result()</code> because the value of a <code>yield from</code> expression on a future is the result (e.g., <code>result = yield from my_future</code>).</li>
</ul>
<p>yielding from <code>Future</code>s, <code>Task</code>s, and coroutines<br>In <code>asyncio</code>, there is a close relationship between futures and coroutines because you can get the result of an <code>asyncio.Future</code> by yielding from it. This means that <code>res = yield from foo()</code> works if <code>foo</code> is a coroutine function (therefore it returns a coroutine object when called) or <strong>if <code>foo</code> is a plain function that returns a <code>Future</code> or <code>Task</code> instance</strong>.</p>
<p>executing coroutines<br>In order to execute, a coroutine must be scheduled, and then it’s wrapped in an <code>asyncio.Task</code>. Given a coroutine, there are two main ways of obtaining a Task:</p>
<p><code>asyncio.async(coro_orfuture, \*, loop=None)</code><br>This function unifies coroutines and futures: the first argument can be either one. If it’s a <code>Future</code> or <code>Task</code>, it’s returned unchanged. <strong>If it’s a coroutine, <code>async</code> calls <code>loop.create_task(...)</code> on it to create a <code>Task</code></strong>. An optional event loop may be passed as the <code>loop=</code> keyword argument; if omitted, <code>async</code> gets the loop object by calling <code>asyncio.get_eventloop()</code>.</p>
<p><code>BaseEventLoop.create_task(coro)</code><br>This method schedules the coroutine for execution and returns an <code>asyncio.Task</code> object. If called on a custom subclass of <code>BaseEventLoop</code>, the object returned may be an instance of some other Task-compatible class provided by an external library (e.g., Tornado).</p>
<ul>
<li>A coroutine only does anything when <strong>driven</strong>, and to drive an <code>asyncio.coroutine</code> you either use <code>yield from</code> or pass it to one of several <code>asyncio</code> functions that take coroutine or future arguments, such as <strong><code>run_untilcomplete</code></strong>. Several <code>asyncio</code> functions accept coroutines and wrap them in <code>asyncio.Task</code> objects automatically, <strong>using <code>asyncio.async</code> internally</strong>. One example is <strong><code>BaseEventLoop.run_untilcomplete(...)</code></strong>.</li>
</ul>
<h4 id="Downloading-with-asyncio-and-aiohttp"><a href="#Downloading-with-asyncio-and-aiohttp" class="headerlink" title="Downloading with asyncio and aiohttp"></a>Downloading with <code>asyncio</code> and <code>aiohttp</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flags2_common <span class="keyword">import</span> main, HTTPStatus, Result, save_flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># default set low to avoid errors from remote site, such as</span></span><br><span class="line"><span class="comment"># 503 - Service Temporarily Unavailable</span></span><br><span class="line">DEFAULT_CONCUR_REQ = <span class="number">5</span></span><br><span class="line">MAX_CONCUR_REQ = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, country_code)</span>:</span></span><br><span class="line">        self.country_code = country_code</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN FLAGS3_ASYNCIO</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_get</span><span class="params">(url)</span>:</span></span><br><span class="line">    res = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.request(<span class="string">'GET'</span>, url)</span><br><span class="line">    <span class="keyword">if</span> res.status == <span class="number">200</span>:</span><br><span class="line">        ctype = res.headers.get(<span class="string">'Content-type'</span>, <span class="string">''</span>).lower()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'json'</span> <span class="keyword">in</span> ctype <span class="keyword">or</span> url.endswith(<span class="string">'json'</span>):</span><br><span class="line">            data = <span class="keyword">yield</span> <span class="keyword">from</span> res.json()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = <span class="keyword">yield</span> <span class="keyword">from</span> res.read()</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> res.status == <span class="number">404</span>:</span><br><span class="line">        <span class="keyword">raise</span> web.HTTPNotFound()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> aiohttp.errors.HttpProcessingError(</span><br><span class="line">            code=res.status, message=res.reason,</span><br><span class="line">            headers=res.headers)</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_country</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/metadata.json'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    metadata = <span class="keyword">yield</span> <span class="keyword">from</span> http_get(url)</span><br><span class="line">    <span class="keyword">return</span> metadata[<span class="string">'country'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(base_url, cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(base_url, cc=cc.lower())</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> http_get(url))</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, base_url, semaphore, verbose)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># A semaphore is used as a context manager in a `yield from` expression so that the system </span></span><br><span class="line">        <span class="comment"># as whole is not blocked: *only this coroutine* is blocked while the semaphore counter is at the </span></span><br><span class="line">        <span class="comment"># maximum allowed number.</span></span><br><span class="line">        <span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> semaphore):</span><br><span class="line">            image = <span class="keyword">yield</span> <span class="keyword">from</span> get_flag(base_url, cc)</span><br><span class="line">        <span class="keyword">with</span> (<span class="keyword">yield</span> <span class="keyword">from</span> semaphore):</span><br><span class="line">            country = <span class="keyword">yield</span> <span class="keyword">from</span> get_country(base_url, cc)</span><br><span class="line">    <span class="keyword">except</span> web.HTTPNotFound:</span><br><span class="line">        status = HTTPStatus.not_found</span><br><span class="line">        msg = <span class="string">'not found'</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="comment"># Any other exception will be reported as a `FetchError` with the country code and the original </span></span><br><span class="line">        <span class="comment"># exception chained using the `raise X from Y` syntax introduced in PEP 3134 — Exception </span></span><br><span class="line">        <span class="comment"># Chaining and Embedded Tracebacks.</span></span><br><span class="line">        <span class="keyword">raise</span> FetchError(cc) <span class="keyword">from</span> exc</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        country = country.replace(<span class="string">' '</span>, <span class="string">'_'</span>)</span><br><span class="line">        filename = <span class="string">'&#123;&#125;-&#123;&#125;.gif'</span>.format(country, cc)</span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        <span class="comment"># Behind the scenes, the `asyncio` event loop has a thread pool executor, and you can send callables to be </span></span><br><span class="line">        <span class="comment"># executed by it with `run_in_executor`. This prevent the I/O function `save_fig` from blocking the whole thread.</span></span><br><span class="line">        loop.run_in_executor(<span class="keyword">None</span>, save_flag, image, filename)</span><br><span class="line">        status = HTTPStatus.ok</span><br><span class="line">        msg = <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose <span class="keyword">and</span> msg:</span><br><span class="line">        print(cc, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result(status, cc)</span><br><span class="line"><span class="comment"># END FLAGS3_ASYNCIO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloader_coro</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    counter = collections.Counter()</span><br><span class="line">    <span class="comment"># Calling `.acquire()` does not block when the counter is greater than zero, but if the counter is zero, </span></span><br><span class="line">    <span class="comment"># `.acquire()` will block the calling *coroutine* until some other coroutine calls `.release()` on the same </span></span><br><span class="line">    <span class="comment"># `Semaphore`, thus incrementing the counter.</span></span><br><span class="line">    semaphore = asyncio.Semaphore(concur_req)</span><br><span class="line">    to_do = [download_one(cc, base_url, semaphore, verbose)</span><br><span class="line">             <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that the futures returned by `asyncio.as_completed` are not necessarily the same </span></span><br><span class="line">    <span class="comment"># futures passed into the `as_completed` call.</span></span><br><span class="line">    to_do_iter = asyncio.as_completed(to_do)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verbose:</span><br><span class="line">        to_do_iter = tqdm.tqdm(to_do_iter, total=len(cc_list))</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> to_do_iter:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = <span class="keyword">yield</span> <span class="keyword">from</span> future</span><br><span class="line">        <span class="keyword">except</span> FetchError <span class="keyword">as</span> exc:</span><br><span class="line">            country_code = exc.country_code</span><br><span class="line">            <span class="comment"># Try to retrieve the error message from the original exception (`__cause__`).</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                error_msg = exc.__cause__.args[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># If the error message cannot be found in the original exception, use the name </span></span><br><span class="line">            <span class="comment"># of the chained exception class as the error message.</span></span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                error_msg = exc.__cause__.__class__.__name__</span><br><span class="line">            <span class="keyword">if</span> verbose <span class="keyword">and</span> error_msg:</span><br><span class="line">                msg = <span class="string">'*** Error for &#123;&#125;: &#123;&#125;'</span></span><br><span class="line">                print(msg.format(country_code, error_msg))</span><br><span class="line">            status = HTTPStatus.error</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            status = res.status</span><br><span class="line"></span><br><span class="line">        counter[status] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, base_url, verbose, concur_req)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    coro = downloader_coro(cc_list, base_url, verbose, concur_req)</span><br><span class="line">    counts = loop.run_until_complete(coro)</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counts</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)</span><br></pre></td></tr></table></figure>
<h4 id="asyncio-Servers"><a href="#asyncio-Servers" class="headerlink" title="asyncio Servers"></a><code>asyncio</code> Servers</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> charfinder <span class="keyword">import</span> UnicodeNameIndex </span><br><span class="line"></span><br><span class="line">CRLF = <span class="string">b'\r\n'</span></span><br><span class="line">PROMPT = <span class="string">b'?&gt; '</span></span><br><span class="line">index = UnicodeNameIndex()</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_queries</span><span class="params">(reader, writer)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># can't `yield from` since the `StreamWriter.write` method is not a coroutine, just a plain function</span></span><br><span class="line">        writer.write(PROMPT)</span><br><span class="line">        <span class="comment"># `StreamWriter.drain` flushes the writer buffer; it is a coroutine, so it must be called with `yield from`.</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()</span><br><span class="line">        data = <span class="keyword">yield</span> <span class="keyword">from</span> reader.readline()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            query = data.decode().strip() </span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            query = <span class="string">'\x00'</span></span><br><span class="line">        client = writer.get_extra_info(<span class="string">'peername'</span>) </span><br><span class="line">        print(<span class="string">'Received from &#123;&#125;: &#123;!r&#125;'</span>.format(client, query)) </span><br><span class="line">        <span class="keyword">if</span> query:</span><br><span class="line">            <span class="keyword">if</span> ord(query[:<span class="number">1</span>]) &lt; <span class="number">32</span>: </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            lines = list(index.find_description_strs(query)) </span><br><span class="line">            <span class="keyword">if</span> lines:</span><br><span class="line">                writer.writelines(line.encode() + CRLF <span class="keyword">for</span> line <span class="keyword">in</span> lines) </span><br><span class="line">            writer.write(index.status(query, len(lines)).encode() + CRLF)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> writer.drain()</span><br><span class="line">            print(<span class="string">'Sent &#123;&#125; results'</span>.format(len(lines)))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Close the client socket'</span>) </span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(address=<span class="string">'127.0.0.1'</span>, port=<span class="number">2323</span>)</span>:</span> </span><br><span class="line">    port = int(port)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># When completed, the coroutine object returned by `asyncio.start_server`</span></span><br><span class="line">    <span class="comment"># returns an instance of `asyncio.Server`, a TCP socket server.</span></span><br><span class="line">    server_coro = asyncio.start_server(handle_queries, address, port,</span><br><span class="line">                                loop=loop)</span><br><span class="line">    <span class="comment"># Drive server_coro to bring up the server.</span></span><br><span class="line">    server = loop.run_until_complete(server_coro)</span><br><span class="line">    host = server.sockets[<span class="number">0</span>].getsockname()</span><br><span class="line">    print(<span class="string">'Serving on &#123;&#125;. Hit CTRL-C to stop.'</span>.format(host)) </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Run the event loop; this is where `main` will block until killed when CTRL-C is </span></span><br><span class="line">        <span class="comment"># pressed on the server console.</span></span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt: <span class="comment"># CTRL+C pressed</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Server shutting down.'</span>) </span><br><span class="line">    server.close() </span><br><span class="line">    <span class="comment"># `server.wait_closed()` returns a future; use `loop.run_until_complete` to let the future do its job.</span></span><br><span class="line">    loop.run_until_complete(server.wait_closed()) </span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    main(*sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/21/Python-generators-coroutines-and-asyncio-library-2/" data-id="cipnq4njk000g3j4kknn4nbdq" class="article-share-link">Share</a>
      
        <a href="http://yoursite.com/2016/03/21/Python-generators-coroutines-and-asyncio-library-2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/26/mit-distributed-system-course-summary/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Summary for MIT 6.824- Course projects
        
      </div>
    </a>
  
  
    <a href="/2016/03/20/Python-generators-coroutines-and-asyncio-library-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Python coroutines and asyncio library (1)</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">programming</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emacs/">Emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Kernel/">Linux Kernel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/distributed-system/">distributed-system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming/">programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/puzzle/">puzzle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Emacs/" style="font-size: 10px;">Emacs</a> <a href="/tags/Linux-Kernel/" style="font-size: 20px;">Linux Kernel</a> <a href="/tags/distributed-system/" style="font-size: 10px;">distributed-system</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/puzzle/" style="font-size: 10px;">puzzle</a> <a href="/tags/python/" style="font-size: 20px;">python</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/26/mit-distributed-system-course-summary/">Summary for MIT 6.824- Course projects</a>
          </li>
        
          <li>
            <a href="/2016/03/21/Python-generators-coroutines-and-asyncio-library-2/">Python coroutines and asyncio library (2)</a>
          </li>
        
          <li>
            <a href="/2016/03/20/Python-generators-coroutines-and-asyncio-library-1/">Python coroutines and asyncio library (1)</a>
          </li>
        
          <li>
            <a href="/2016/02/22/A-Superhard-Elementary-Math-Problem/">A Superhard Elementary Math Problem</a>
          </li>
        
          <li>
            <a href="/2016/02/20/numpy-with-cython/">Numpy with Cython</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 xyguo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/links" class="mobile-nav-link">Links</a>
  
</nav>
    
<script>
  var disqus_shortname = 'xyguo';
  
  var disqus_url = 'http://yoursite.com/2016/03/21/Python-generators-coroutines-and-asyncio-library-2/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>




  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>